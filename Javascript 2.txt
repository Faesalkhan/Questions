Ability to store a value in a variable and pulling out its value gives a program a state.
without this ability our program would be very limited.
but where do these variables live? where are they stored? how does our program find them when it needs them?
scope : well defined set of rules for storing the variables and finding them in later time.

Compilation -----------------------------------------
code undergoes into 3 steps.

tokenizing/lexing :breaking up string into a meaningful chunks, called tokens. so var a = 2; is var, a, =, 2, ;,

parsing : taking a stream/array of tokens and turning it into a tree(AST, abstract syntax tree) of nested elements,
which collectively called grammatical structure of the program.
tree for var a = 2; the tree will start with 
top level node ----> variableDeclaration.
a child node -----> identifier.
another child node -----> assignmentExpression. itself has a child node numericLiteral(whose value is 2).

code generation : process of taking AST and turning it into executable code.
var a = 2 ; taking this AST and turn it into a machine instructions to actually create a variable a (including reserving
memory) then store a value into a.

For JS compilation occurs in microseconds or less before the code is executed.
so JS compiler will take the program var a = 2; and compile it first, and then ready to execute it. 

Undertanding scope ----------------------------------------
the cast 
Engine :   responsible for start-to-end compilation and execution of our JS program.
Compiler : Engine's friend, handles all the dirty works of parsing and code-generation.
Scope :    another friend, collects and maintains a look-up list of all the declared identifiers/variables,
           and enforces a set of rules as how these are accessible to currently executing code.

var a = 2; 
first compiler will perform the lexing to break it down into tokens, which it will then parse into a tree.
But when compiler gets to code-generation, it treat the program differently than somewhat assumed.
“Allocate memory for a variable, label it a, then stick the value 2 into that variable" (unfortunately not this assumption).

compiler will proceed as :
encountering a compiler will ask the scope if particular variable already exists for that particular scope collection.
if so then compiler ignores it and moves on. otherwise compiler asks scope to declare a variable called 'a' for
that scope collection.

compiler then produce the code for Engine to later execute, to handle the a=2 assignment.
Engine will ask the scope if there is a variable 'a' accessible in current scope collection.
if so then engine use it. if not then engine looks elsewhere(like in nested scope).

if engine finds a variable, it assign the value 2 to it. if not engine will raise its hand and yell out an error.

To summarize: two distinct actions are taken for a variable assignment:
First, Compiler declares a variable (if not previously declared) in the
current Scope, and second, when executing, Engine looks up the variable in Scope and assigns to it, if found.

when engine executes the code, it has to 'look up' the variable 'a' to see if it has been declared, and this look-up
is consulting scope.
Engine would be performing LHS and RHS look-up (left or right of = assignment).
LHS look-up : look up for value of some variable.
RHS look-up : look up for variable container itself, so that it can asssign. (it means not LHS) (go get the value of...)
e.g: 

console.log(a);
nothing is assigned to 'a' here. it is saying that 'go get the value of a'. so RHS look up.

var a = 2 ;
here is LHS, assigning the value to a (target) variable. (who is the target of assignment, LHS).

function foo(a){
  console.log(a);
}
foo(2);

foo(..) is the function invoking, meaning, 'go get the value of foo and give it to me'.(its value has to be executed).
so it is RHS.
value 2 is passed as argument to foo, and foo received that as parameter 'a'. so assignment, so LHS.
again console.log(..) is looking for 'a' is RHS look-up (it needs 'a' reference to be executed).
It’s an RHS look-up for the console object, then a property resolution occurs to see if it has a method called log.

"function declaration is not LHS look-up".

function foo(a){
  var b = a;
  return a+b;
}
var c = foo(2);

how many LHS and RHS. ----------------> 3,4
c = ..;, a = 2 , b = ..
foo(2.., = a;, a .. and .. b

Nested Scope ---------------------------------------------------
scope is a set of rules for looking up variables by their identifier name. there's usually more than one scope to consider.
if scopes are nested, if a variable is not found in inner scope then engine will find it outer scope, if not then
continuing until global scope has been reached.

function foo(a) {
  console.log(a+b);
}
let b = 3;
foo(2);              // 5

Errors ------------------------------------------------
function foo(a) {
  console.log(a+b);
  b = a;
}
foo(2);

Uncaught ReferenceError: b is not defined

when RHS look-up is for 'b' for the first time, it will not be found in the scope. it is said to be 'undeclared'.
If RHS lookup ever fails to find variable, this results in 'ReferenceError'. (error is type of ReferenceError).

By contrast, if the engine is performing an LHS look-up, and it arrives
at the top floor (global scope) without finding it, if the program is not running in “Strict Mode,”
then the global scope will create a new variable of that name in the global scope, and hand it back to Engine.
“No, there wasn’t one before, but I was helpful and created one for you.”

"Strict Mode" disallows the automatic/implicit global variable creation.
in that case LHS lookup will give a ReferenceError.

if a variable is found by RHS lookup, and we are trying to do something that is not possible with that,
(reference a property on a null or undefined value,  trying to execute as function a nonfunction value)
then it will give type of error called 'TypeError'.

ReferenceError is scope resolution-failure related, whereas TypeEr
ror implies that scope resolution was successful, but that there was an
illegal/impossible action attempted against the result.

Unfulfilled RHS references result in ReferenceErrors being thrown.
Unfulfilled LHS references result in an automatic, implicitly created
global of that name (if not in Strict Mode), or a ReferenceError (if in
Strict Mode).

---------------------------------------scope bubble
Scope consist of series of "bubbles" that each act as a container/bucket, in which identifiers (variables, functions)
are declared.

function foo(a) {
 var b = a * 2;
 function bar(c) {
 console.log( a, b, c );
 }
 bar( b * 3 );
}
foo( 2 ); // 2, 4, 12

Bubble 1 encompasses the global scope and has just one identifier in it: foo.
Bubble 2 encompasses the scope of foo, which includes the three identifiers: a, bar, and b.
Bubble 3 encompasses the scope of bar, and it includes just one identifier: c.

scope bubbles are defined by where the blocks of scope are written, which one is nested inside other, etc.
(functions creates a new bubble of scope, is it only function that does this? )
notice how these bubbles are strictly nested. they are not crossing the boundaries.
i.e. no bubble for some function can simultaneously exist inside two other outer scope bubbles.
like no function can partially be inside each of two parent functions.

calling bar in global scope will not work,
bar();                    // fails
console.log(a,b,c);       // all 3 fails
a,b,c and bar all identifiers are available only inside foo().

Scope from functions ---------------------------------------------
each function you declare creates a bubble for itself.

wrapping the code inside the function declaration makes the code hide. (making a bubble around the code).
i.e. we can hide variables and functions by enclosing them into a scope of function.
(you should expose only what is minimally necessary, and hide everything (Principle of least privilege)).
as proper use of the code would discourage access to those variables/functions.

consider this : 
function doSomething(a) {
  b = a + doSomethingElse( a * 2 );
  console.log( b * 3 );
}
function doSomethingElse(a) {
  return a - 1;
}
var b;
doSomething( 2 );        // 15

in this code, doSomethingElse(), b are present in global scope. then doSomething() use them.
proper way of doing this is 

function doSomething(a) {
  function doSomethingElse(a) {
  return a - 1;
 }
  var b;
  b = a + doSomethingElse( a * 2 );
  console.log( b * 3 );
}
doSomething( 2 );        // 15

now b, doSomethinElse() are not accessible to any outside influence, instead controlled by doSomething().
functionality and end result has not been affected. but design keeps private details.

collision avoidance -----------------------------------------
this is another benefit of hiding, avoiding collision between two different identifiers with same name but different
intended usages. collision results often in unexpected overwriting of values.

https://medium.com/@swati.developer17/part-10-block-scope-function-scope-and-shadowing-in-js-eb0043b93588

var a = 9;
function foo() {
    var a = 19;
    console.log(a);       // 19
}
foo();
console.log(a);           // 9

here we have to call functions foo(), to execute its code. we want that code without calling foo().

here function is treated as an expression---------------------

var a = 9;
(function foo() {
  var a = 19;
  console.log(a);
})();
console.log(a);

first pair of () makes it a expression and another pair of () executes it.
it is also called IIFE (Immediately Invoked Function Expression).
if 'function' is at beginning then it is function declaration. otherwise expression.

Anonymous function -----------------------
here is the function expressions as callback parameters.

setTimeout( function(){
 console.log("I waited 1 second!");
}, 1000 );

here function has no name identifier on it.
function expression can be anonymous but function declaration cannot omit the name (that would be illegal).
(many suggest to use function expression, but it has its own drawbacks, providing name to it will address all drawbacks)

setTimeout( function timeoutHandler(){        //Look, I have a name!
 console.log( "I waited 1 second!" );
}, 1000 );

Blocks as Scopes ---------------------------------------------------------

for (var i=0; i<10; i++) {
 console.log( i );
}

variable declaring using 'var' are available to global and function scope (they are not block scoped).
it means that in the above example 'var' is available for 'for' loop as well as outside of it.
so it is not desirable (against the rule of PLP).
Block scope is a tool to extend the earlier Principle of Least Privilege from hiding information in functions to hiding information in blocks of our code.

later ES6 introduced 'let' and 'const' which are block scoped (attaches variables to the scope of block).
(it hijacks block's scope for its variable decalaration).

{
  let a = 10;
  console.log(a);         // 10
}
console.log(a);           // ReferenceError: a is not defined

A particular case where let shines is in the for loop.
for (let i=0; i<10; i++) {
 console.log( i );
}
console.log( i ); // ReferenceError

Not only does let in the for loop header bind the i to the for loop body, but in fact, it rebinds it to each iteration
of the loop, making sure to reassign it the value from the end of the previous loop iteration.
{
 let j;
 for (j=0; j<10; j++) {
 let i = j; // re-bound for each iteration!
 console.log( i );
 }
}

try/catch ----------------------------------------------------------------
It’s a very little known fact that JavaScript in ES3 specified the variable
declaration in the catch clause of a try/catch to be block-scoped to
the catch block.
For instance:
try {
 undefined(); // illegal operation to force an exception!
}
catch (err) {
 console.log( err ); // works!
}
console.log( err ); // ReferenceError: `err` not found

